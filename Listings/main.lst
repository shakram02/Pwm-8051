C51 COMPILER V9.54   MAIN                                                                  04/26/2017 08:09:29 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(1,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <at89c51xd2.h>
   2          #include <stdio.h>
   3          
   4          #define PERIOD_MICROS (22.1184/12)  /* 8051 cycle time in microseconds */
   5          #define BYTE_SIZE 8
   6          #define TO_MIRCOS 1000000 /* 10^6 to convert time in secs to micros */
   7          #define FREQ_500HZ_MICROS 2000  /* 500Hz frequency in microseconds */
   8          sbit led = P2^0; /* Use P2.0 for your output generated signal. */
   9          sbit error_led = P2^6;
  10          sbit output_ctl = P2^7; /* P2.7 to turn the output signal ON and OFF */
  11          
  12          /* Adjust mode */
  13          sbit adjust_mode= P2^5;
  14          sbit adjust_led = P2^4;
  15          
  16          typedef struct TIMER_VALS{
  17            char th;
  18            char tl;
  19          }TIMER_VALS;
  20          
  21          void adjust_state();
  22          void output_half_cycle(TIMER_VALS* tv);
  23          int calc_micros_config(int micros,TIMER_VALS* tv);
  24          char duty_cycle(unsigned char percent);
  25          int to_micros(int);
  26          void error_state();
  27          
  28          /* ON/OFF values for duty cycle */
  29          TIMER_VALS tv_on;
  30          TIMER_VALS tv_off;
  31          
  32          void init(){
  33   1        P1 = 0;
  34   1        P2 = 0;
  35   1        output_ctl = 1;
  36   1      }
  37          
  38          void main() using 0{
  39   1        /* Timer 0 mode 1 */
  40   1        init();
  41   1        TMOD  = 0x01;
  42   1        
  43   1        
  44   1          /* For testing correctness */
  45   1      //  if (calc_micros_config(2000,&tv))
  46   1      //  {
  47   1      //    error_state();
  48   1      //  }
  49   1        
  50   1        /* Mode 1 of duty cycle -> 25% */
  51   1        if(duty_cycle(5)){
  52   2          error_state();
  53   2        }
  54   1        
C51 COMPILER V9.54   MAIN                                                                  04/26/2017 08:09:29 PAGE 2   

  55   1        /* Port1 is used as input */
  56   1        TR0 = 1;
  57   1        led = 0;
  58   1        while(1){
  59   2          /*output_ctl*/
  60   2          while (!adjust_mode){
  61   3            /* Operate the timer using tv_on when it overflows, switch to tv_off */
  62   3      //      TF0 = 0;
  63   3      //      TH0 = tv_off.th;
  64   3      //      TL0 = tv_off.tl;
  65   3      //      while(TF0 == 0);
  66   3      //      led = ~led;   
  67   3            output_half_cycle(&tv_off);
  68   3            output_half_cycle(&tv_on);
  69   3          }
  70   2          
  71   2          if(adjust_mode){
  72   3            adjust_state();
  73   3          }
  74   2        }
  75   1        
  76   1      }
  77          
  78          void output_half_cycle(TIMER_VALS* tv){
  79   1        TF0 = 0;
  80   1        TH0 = tv->th;
  81   1        TL0 = tv->tl;
  82   1        while(TF0 == 0);
  83   1        led = ~led;     
  84   1      }
  85          
  86          int to_micros(int hertz){
  87   1        /* Not working, values are zeroed */
  88   1        double val = (1/hertz);
  89   1        unsigned long int micros= val * TO_MIRCOS;
  90   1        return micros;
  91   1      }
  92          
  93          void adjust_state(){
  94   1        /* TODO */ 
  95   1        return ;
  96   1      }
  97          
  98          /*
  99            Calculates the timer values for the supplied mode of duty
 100            cycle, the code is ugly because I couldn't create the calculations
 101            with double values as the values in double/long operations 
 102            were zeroed for a reason that I don't know.
 103          */
 104          char duty_cycle(unsigned char mode){
 105   1        char on=1,off=1;
 106   1        
 107   1        if(mode == 1)
 108   1        {
 109   2          /*20%*/
 110   2          on = calc_micros_config(400,&tv_on);
 111   2          off = calc_micros_config(1600,&tv_off);
 112   2        }
 113   1        else if(mode == 2)
 114   1        {
 115   2          /*25%*/
 116   2          on = calc_micros_config(500,&tv_on);
C51 COMPILER V9.54   MAIN                                                                  04/26/2017 08:09:29 PAGE 3   

 117   2          off = calc_micros_config(1500,&tv_off);
 118   2        }
 119   1        else if(mode == 3)
 120   1        {
 121   2          /*50%*/
 122   2          on = calc_micros_config(800,&tv_on);
 123   2          off = calc_micros_config(800,&tv_off);
 124   2        }
 125   1        else if(mode == 4)
 126   1        {
 127   2          /*75%*/
 128   2          on = calc_micros_config(1500,&tv_on);
 129   2          off = calc_micros_config(500,&tv_off);
 130   2        }
 131   1        else if(mode == 5)
 132   1          {
 133   2          /*80%*/
 134   2          on = calc_micros_config(1600,&tv_on);
 135   2          off = calc_micros_config(400,&tv_off);
 136   2        }   
 137   1        
 138   1        return on || off;
 139   1      }
 140          
 141          /* Calculates TH and TL values to generate a given delay in microseconds */
 142          int calc_micros_config(int micros,TIMER_VALS* tv){
 143   1        /* Get the number of increments required */
 144   1        int incr = micros * PERIOD_MICROS;
 145   1        int start_val;
 146   1        
 147   1        if (OV)
 148   1        {
 149   2          /* Overflow, Indicate error */
 150   2          OV = 0;
 151   2          return -1;
 152   2        }
 153   1        
 154   1        start_val = 0xFFFF - incr;
 155   1        tv->tl = start_val & 0x00FF;  /* The LOW part of the delay */
 156   1        tv->th = ((start_val & 0xFF00) >> BYTE_SIZE); /* The HIGH part of the delay */
 157   1          
 158   1        return 0;
 159   1      }
 160          
 161          void error_state(){
 162   1          TMOD = 0x00;
 163   1          error_led = 1;
 164   1          while(1);
 165   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    500    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
